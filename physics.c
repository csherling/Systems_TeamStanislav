#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h> //does time exist tho?
#include "physics.h"

double signum(double x) {
    if (x > 0.0) {
        return 1.0;
    }
    if (x < 0.0) {
        return -1.0;
    }
    return 0.0;
}


/**
 * Returns an arrow with a velocity of `v` at angle `angle`,
 * with its tail at the origin.
 */
arrow make_arrow(double v, double angle) {
    arrow result;
    result.vx = cos(angle) * v;
    result.vy = sin(angle) * v;
    result.x = 0;
    result.y = 0;
    return result;
}

/*Params:
 shooter: pointer to the player who is shooting the arrow
 target: point to the player who is being shot at
 v: initial velocity positive and negative
 Returns:
 1-Hit
 0-Miss
 */
char shoot(
        player *shooter,
        player *target,
        arrow *arrow,
        // Terrain seeds:
	seed s
        ) {
  arrow->x = shooter->xcor;
  arrow->y = PLAYER_HEIGHT+getTerrain(shooter->xcor, s);
  while(arrow->y>=0+getTerrain(arrow->x, s)){
    //Movements
    shootStep(target, arrow, s);
  }
  if(signum(arrow->vx)*(target->xcor - arrow->x)<0){
    overshoot(fabs(arrow->x - target->xcor));
  }else{
    undershoot(fabs(target->xcor - arrow->x));
  }
  return 0;
}

int shootStep(
	      player *target,
	      arrow *arrow,
	      seed s
	      ) {
  arrow->vy-=GRAVITY*.01;
  arrow->x+=arrow->vx*.01;
  arrow->y+=arrow->vy*.01;
  processCor(arrow->x, arrow->y,atan2(arrow->vy, arrow->vx));
  if(arrow->x >= target->xcor && arrow->x <= target->xcor + PLAYER_WIDTH){
    if(arrow->y<=PLAYER_HEIGHT+getTerrain(target->xcor, s)){
      kill(target);
      return 1;
    }
  }
}

void processCor(double x, double y, double theta){
  printf("(%f,%f) Angle: %f\n",x,y,theta);
}

void kill(player *p){
  p->health-=1;
  printf("HIT! new health: %d\n",p->health);
}

void overshoot(int distance){
  printf("MISSED! overshot by %d\n",distance);
}

void undershoot(int distance){
  printf("MISSED! undershot by %d\n",distance);
}

//sets the seeds to be used in getTerrain
void setSeeds(seed *s){
  srand(time(NULL));//Note srand is applicable in function because this is called once per game
  s->s1 = (double)rand()/(double)RAND_MAX*100;//not sure why but first result is always small
  s->s2 = (double)rand()/(double)RAND_MAX;
  s->s3 = (double)rand()/(double)RAND_MAX;
  s->s4 = (double)rand()/(double)RAND_MAX;
  printf("Random seeds %f, %f, %f, %f\n", s->s1, s->s2, s->s3, s->s4);
}

//Generates hilly terrain using trigonometric functions
//Uses sine and cosine, with coefficients generated by the four seed values
// between 0 and 1
double getTerrain(double x, seed s){
  double ret;
  ret = 0;
  ret+=(s.s1*10)*(sin(x*s.s2));
  s.s1 = 1-s.s1;
  s.s2 = 1-s.s2;
  ret+=(s.s1*10)*(sin(x*s.s2));
  ret+=(s.s3*10)*(cos(x*s.s4));
  s.s3 = 1-s.s3;
  s.s4 = 1-s.s4;
  ret+=(s.s3*10)*(cos(x*s.s4));
  return ret;
}

void processTerrain(double x, double y){
  printf("(%f,%f\n)",x,y);
}

//display displays the terrain initially. It uses the current computer to determine what piece of the terrain to display
void display(char comp, char numcoms, seed s){
  double xi = (double)comp*DISTANCE/numcoms;
  while(xi<(double)(comp+1)*DISTANCE/numcoms){
    processTerrain(xi, getTerrain(xi, s));
    xi+=.01;
  }
}
